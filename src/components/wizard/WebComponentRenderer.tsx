import { useLayoutEffect, useRef, useState } from 'react';
import { ResumeData } from '@/types';

interface WebComponentRendererProps {
  tagName: string;
  jsCode: string;
  data: ResumeData;
  className?: string;
  style?: React.CSSProperties;
  language?: string;
  theme?: string;
  accent?: string;
}

/**
 * Sanitize tagName to create a valid JavaScript identifier for class name
 * Example: 'template-1763438319813' -> 'Template1763438319813'
 */
function sanitizeTagNameForClassName(tagName: string): string {
  return tagName
    .split('-')
    .map(part => {
      // Capitalize first letter, keep rest as-is
      if (part.length === 0) return '';
      return part.charAt(0).toUpperCase() + part.slice(1);
    })
    .join('');
}

export function WebComponentRenderer({
  tagName,
  jsCode,
  data,
  className,
  style,
  language,
  theme,
  accent,
}: WebComponentRendererProps) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const elementRef = useRef<HTMLElement | null>(null);
  const scriptRef = useRef<HTMLScriptElement | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useLayoutEffect(() => {
    let mounted = true;

    async function loadAndRender() {
      try {
        setLoading(true);
        setError(null);

        console.log('üîç [WebComponentRenderer] Loading Web Component:', { tagName, codeLength: jsCode.length });

        // Check if custom element is already registered
        let elementDefined: CustomElementConstructor | undefined = customElements.get(tagName);
        console.log('üîç [WebComponentRenderer] Element already defined?', !!elementDefined);

        // CRITICAL FIX: Replace hardcoded 'resume-component' with the actual tagName
        // Templates generated by the template generator app hardcode 'resume-component'
        // but the API stores a different tagName (e.g., 'free-001')
        let interceptedCode = jsCode;
        
        // Check what tagName is actually in the code
        const codeTagNameMatch = jsCode.match(/customElements\.define\(['"]([^'"]+)['"]/);
        const codeTagName = codeTagNameMatch ? codeTagNameMatch[1] : null;
        console.log('üîç [WebComponentRenderer] TagName in code:', codeTagName, 'Expected:', tagName);
        
        // If the code has a different tagName than expected, replace it
        if (codeTagName && codeTagName !== tagName) {
          console.log('üîç [WebComponentRenderer] Replacing tagName in code:', codeTagName, '‚Üí', tagName);
          // Replace all occurrences of the old tagName with the new one
          const escapedOldTagName = codeTagName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          interceptedCode = interceptedCode.replace(
            new RegExp(escapedOldTagName, 'g'),
            tagName
          );
          console.log('üîç [WebComponentRenderer] Code replaced successfully');
        }
        
        // CRITICAL FIX: Replace ResumeComponent class name with unique name to avoid conflicts
        // All templates use the same class name 'ResumeComponent', causing conflicts when
        // multiple templates are loaded in the same global scope (e.g., gallery view)
        const originalClassName = 'ResumeComponent';
        const sanitizedTagName = sanitizeTagNameForClassName(tagName);
        const uniqueClassName = `${originalClassName}${sanitizedTagName}`;
        
        // Check if the code contains the standard class name
        const hasResumeComponent = /\bclass\s+ResumeComponent\b/.test(interceptedCode);
        
        if (hasResumeComponent && originalClassName !== uniqueClassName) {
          console.log('üîç [WebComponentRenderer] Replacing class name:', originalClassName, '‚Üí', uniqueClassName);
          
          // Replace class declaration: class ResumeComponent extends HTMLElement
          interceptedCode = interceptedCode.replace(
            /\bclass\s+ResumeComponent\b/g,
            `class ${uniqueClassName}`
          );
          
          // Replace class reference in customElements.define: customElements.define('tagName', ResumeComponent)
          // Use word boundary to avoid partial matches
          interceptedCode = interceptedCode.replace(
            new RegExp(`\\b${originalClassName}\\b`, 'g'),
            uniqueClassName
          );
          
          console.log('üîç [WebComponentRenderer] Class name replaced successfully');
        } else if (!hasResumeComponent) {
          console.log('üîç [WebComponentRenderer] No ResumeComponent class found, skipping class name replacement');
        }
        
        const isAlreadyDefined = customElements.get(tagName);
        
        if (isAlreadyDefined) {
          // Modificar el c√≥digo para que no intente definir el elemento si ya est√° registrado
          const escapedTagName = tagName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const definePattern = new RegExp(
            `customElements\\.define\\((['"])${escapedTagName}\\1[^)]*\\)`,
            'g'
          );
          interceptedCode = interceptedCode.replace(definePattern, (match) => {
            // Reemplazar con una verificaci√≥n que evita redefinir
            return `if (!customElements.get('${tagName}')) { ${match} }`;
          });
          console.log('üîç [WebComponentRenderer] Intercepted code to avoid redefinition of', tagName);
          // Si ya est√° definido, no necesitamos cargar el script
          elementDefined = isAlreadyDefined;
        }

        if (!elementDefined) {
          // Create a blob URL from the JS code
          const blob = new Blob([interceptedCode], { type: 'application/javascript' });
          const blobUrl = URL.createObjectURL(blob);

          // Create and inject script tag
          const script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = blobUrl;
          script.id = `template-script-${tagName}`;
          scriptRef.current = script;

          // Wait for script to load
          await new Promise<void>((resolve, reject) => {
            script.onload = () => {
              console.log('üîç [WebComponentRenderer] Script loaded successfully');
              resolve();
            };
            script.onerror = (err) => {
              console.error('üîç [WebComponentRenderer] Script load error:', err);
              URL.revokeObjectURL(blobUrl);
              reject(new Error(`Failed to load template script for ${tagName}`));
            };
            document.head.appendChild(script);
          });

          // Wait for custom element to be registered
          let attempts = 0;
          const maxAttempts = 30;
          console.log('üîç [WebComponentRenderer] Waiting for custom element registration...');
          while (attempts < maxAttempts && !elementDefined && mounted) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
            elementDefined = customElements.get(tagName);
            if (elementDefined) {
              console.log('üîç [WebComponentRenderer] Custom element registered after', attempts, 'attempts');
              break;
            }
            // Log all registered custom elements for debugging
            if (attempts % 10 === 0) {
              console.log('üîç [WebComponentRenderer] Attempt', attempts, '- Checking for tagName:', tagName);
              // Try to get all registered elements (this might not work in all browsers)
              try {
                const allElements: string[] = [];
                // Check common tag names that might be registered
                const commonTags = ['resume-component', tagName, 'free-001', 'resume-template'];
                commonTags.forEach(tag => {
                  if (customElements.get(tag)) {
                    allElements.push(tag);
                  }
                });
                console.log('üîç [WebComponentRenderer] Found registered elements:', allElements);
              } catch (e) {
                console.log('üîç [WebComponentRenderer] Could not list registered elements');
              }
            }
          }

          if (!elementDefined) {
            URL.revokeObjectURL(blobUrl);
            // Try to find what was actually registered
            const commonTags = ['resume-component', tagName, 'free-001', 'resume-template'];
            const foundTags = commonTags.filter(tag => customElements.get(tag));
            console.error('üîç [WebComponentRenderer] Custom element not registered. Expected:', tagName);
            console.error('üîç [WebComponentRenderer] Found registered elements:', foundTags);
            console.error('üîç [WebComponentRenderer] Code snippet (first 500 chars):', interceptedCode.substring(0, 500));
            throw new Error(`Custom element "${tagName}" not registered after loading script. Found registered: ${foundTags.join(', ')}`);
          }

          // Clean up blob URL after script is loaded
          URL.revokeObjectURL(blobUrl);
        }

        // Wait for container to be available
        let refAttempts = 0;
        const maxRefAttempts = 10;
        while (refAttempts < maxRefAttempts && (!containerRef.current || !mounted)) {
          await new Promise(resolve => setTimeout(resolve, 50));
          refAttempts++;
          if (!mounted) return;
        }

        if (!containerRef.current || !mounted) {
          throw new Error('Container ref not available');
        }

        // Create or update the custom element
        let element: HTMLElement | null = null;

        if (elementRef.current && 
            containerRef.current.contains(elementRef.current) &&
            elementRef.current.tagName.toLowerCase() === tagName.toLowerCase()) {
          element = elementRef.current;
        } else {
          // Remove old element if exists
          if (elementRef.current && containerRef.current.contains(elementRef.current)) {
            try {
              containerRef.current.removeChild(elementRef.current);
            } catch {
              // Ignore if already removed
            }
          }

          // Create new element
          element = document.createElement(tagName);
          containerRef.current.appendChild(element);
          elementRef.current = element;
        }

        // Hide loading/error elements by setting display: none
        // This avoids removing React-managed elements from the DOM
        // React will handle the conditional rendering, but we hide them visually
        // when the custom element is ready

        // Set attributes
        if (language) element.setAttribute('language', language);
        if (theme) element.setAttribute('theme', theme);
        if (accent) element.setAttribute('accent', accent);

        // Set data property
        (element as any).data = data;

        console.log('Web Component rendered successfully');
        setLoading(false);
      } catch (err) {
        console.error('Error loading Web Component:', err);
        if (mounted) {
          setError(err instanceof Error ? err.message : 'Failed to load template');
          setLoading(false);
        }
      }
    }

    loadAndRender();

    // Cleanup
    return () => {
      mounted = false;
      
      // Clean up script
      if (scriptRef.current) {
        const script = scriptRef.current;
        if (script.parentNode) {
          try {
            script.parentNode.removeChild(script);
          } catch {
            // Ignore if already removed
          }
        }
        scriptRef.current = null;
      }
      
      // Clean up custom element - only remove if it's still a child of the container
      if (elementRef.current && containerRef.current) {
        const element = elementRef.current;
        const container = containerRef.current;
        
        // Verify the element is still a child before attempting to remove
        if (container.contains(element)) {
          try {
            container.removeChild(element);
          } catch (err) {
            // Ignore errors - element may have been removed by React or another process
            console.warn('Could not remove custom element during cleanup:', err);
          }
        }
        elementRef.current = null;
      }
    };
  }, [tagName, jsCode, data, language, theme, accent]);

  return (
    <div 
      ref={containerRef} 
      className={className} 
      style={style}
      data-react-unmanaged="true"
    >
      {error && (
        <div className="p-4 bg-red-50 border border-red-200 rounded">
          <p className="text-red-700 text-sm">Error: {error}</p>
        </div>
      )}
      {loading && !error && (
        <div className="flex items-center justify-center p-8">
          <div className="text-center">
            <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-2"></div>
            <p className="text-gray-600 text-sm">Cargando template...</p>
          </div>
        </div>
      )}
    </div>
  );
}

